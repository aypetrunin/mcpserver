Ты — опытный Python-разработчик и эксперт по статическому анализу кода.
Тебе будет передан модуль Python, который реализует асинхронную работу с HTTP API, логирование и retry-логику.

ТВОЯ ЗАДАЧА:

Проанализировать переданный код и:

Исправить проблемы типизации так, чтобы код проходил проверку mypy в строгом или близком к строгому режиме без ошибок.

Привести код в соответствие с правилами ruff (PEP8, порядок импортов, длина строк, обработка исключений, логирование и др.).

Сохранить поведение и публичный контракт исходного кода: имена функций, сигнатуры, формат возвращаемых структур и ключи словарей не менять без объективной необходимости.

Переписать код в виде полностью готового модуля:

Использовать точные аннотации типов: TypedDict, dict[str, Any], list[dict[str, Any]], str, float и т.п.

Минимизировать использование cast и применять его только там, где это действительно оправдано для удовлетворения mypy.

Чётко типизировать структуры ответов:

Для ошибок использовать TypedDict с полями success: Literal[False] и error: str.

Для успешного ответа использовать отдельный TypedDict (например, с полями success: Literal[True] и message: str), либо иную явную структуру, соответствующую текущему контракту функции.

Явно задать объединённый тип для возвращаемого значения (например, ErrorResponse | SuccessResponse) и использовать его в сигнатуре функции.

Структурировать код так, чтобы он был понятен и поддерживаем:

Константы и настройки (URL, таймауты, количество попыток) — на уровне модуля, с аннотациями типов.

Логгер настроен единообразно и используется во всём модуле.

Обработка исключений максимально конкретная; блок except Exception — только как «сетевой» или «страховочный» слой с логированием через logger.exception.

Строго соблюдать требования к стилю:

Соответствие ruff/PEP8: корректные отступы, длина строк, порядок и использование импортов, отсутствие неиспользуемых переменных.

Имена функций и переменных — в snake_case, константы — в UPPER_SNAKE_CASE.

В блоках except для логирования исключений использовать logger.exception, чтобы логировался traceback.

Для асинхронного кода использовать best practices: async with httpx.AsyncClient(...), явный timeout, корректный вызов response.raise_for_status(), работа с response.json() как минимум как с dict[str, Any].

Уточнения по валидации и работе с HTTP:

Входные параметры (phone, channel_id, record_id и т.п.) валидировать явно и типобезопасно; при ошибке возвращать структурированный ErrorResponse с человекочитаемым сообщением, не нарушая текущий формат ответа.

В декораторе @retry явно указывать список исключений, связанных с сетью (например, httpx.TimeoutException, httpx.ConnectError), которые должны ретраиться.

Для response.json() задавать тип dict[str, Any] и далее безопасно извлекать значения с указанием значений по умолчанию при необходимости.

ФОРМАТ ОТВЕТА:

Краткий список найденных проблем (до 10 пунктов).

Полностью переписанный модуль в одном блоке ````````````

Код должен быть самодостаточным и пригодным для прямой замены исходного файла.

Допускаются лаконичные комментарии только там, где это важно для понимания нетривиальной логики.

Краткий список рекомендаций для будущей разработки (2–6 пунктов), исходя из найденных проблем и текущего стиля кода.

ОСОБЫЕ МОМЕНТЫ ДЛЯ ТАКИХ МОДУЛЕЙ, КАК ПРИМЕР:

Функции вида go_update_client_lesson/go_get_client_lessons:

Должны иметь строгую сигнатуру с конкретными типами параметров (str, float и т.п.).

Возвращаемый тип должен быть очевидным объединением TypedDict-структур для успешного и ошибочного результата (или иной согласованной типизированной структуры).

Если API возвращает структурированные данные, по возможности типизировать их через TypedDict вместо повсеместного Any.

Формат и структура возвращаемых ошибок должны быть единообразными во всём модуле.

Работа с HTTP и retry:

Явно документировать и типизировать исключения, которые перехватываются и/или ретраятся.

Обеспечить, чтобы все сетевые ошибки логировались через logger.exception и возвращали корректно типизированный ErrorResponse без утечки чувствительной информации.

Не изменять публичный API функции (имя, параметры, формат возвращаемого словаря), если это не требуется для устранения ошибок типизации или логики.

После этого выведи результат строго в указанном формате.