# src/clients.py
"""
Назначение этого файла (объяснение для новичка)
===============================================

Зачем вообще нужен "общий" (глобальный) HTTP-клиент?
----------------------------------------------------
В проекте много мест, где вы делаете HTTP-запросы (внешние API, ваши сервисы и т.п.).
Если каждый раз создавать новый httpx.AsyncClient прямо в функции, то:

1) Это медленнее:
   - создание клиента = создание пула соединений + настройка
   - при большом числе запросов это заметно "съедает" время и ресурсы.

2) Это хуже для сети:
   - повторно не используются keep-alive соединения
   - больше TCP/TLS рукопожатий → лишняя задержка.

3) Это сложнее закрывать:
   - легко забыть закрыть клиент (утечки сокетов)
   - или закрыть не там.

Поэтому мы делаем так же, как вы уже делаете с Postgres pool:
- инициализируем ресурс ОДИН раз при старте процесса
- используем его везде
- закрываем ОДИН раз при остановке процесса

Как этот модуль использовать
----------------------------
1) В main_v2.py на старте:
      await init_clients()

2) В любом месте проекта, где нужно сделать HTTP-запрос:
      client = get_http()
      resp = await client.post(...)

3) На shutdown (в finally main_v2.py):
      await close_clients()

Важная идея
-----------
Мы не создаём клиента "на каждый запрос".
Мы создаём его "на весь процесс" и переиспользуем.

"""

from __future__ import annotations  # позволяет использовать "A | B" в аннотациях в старых версиях Python

import logging
import httpx

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------
# ГЛОБАЛЬНАЯ ПЕРЕМЕННАЯ (хранит клиента)
# ---------------------------------------------------------------------
# Здесь будет лежать единственный экземпляр httpx.AsyncClient.
# Пока init_clients() не вызван — значение None.
_http: httpx.AsyncClient | None = None


async def init_clients() -> None:
    """
    Инициализируем (создаём) HTTP-клиент.

    Важно:
    - Эту функцию нужно вызвать РОВНО 1 раз при старте процесса (например, в main_v2.py).
    - Если вызвать второй раз — ничего страшного: функция просто выйдет (это защита).

    Почему async?
    - Создание клиента само по себе не делает сетевых запросов,
      но закрытие клиента точно async, и удобнее держать интерфейс единым.
    """
    global _http  # говорим Python, что мы хотим менять глобальную переменную _http

    # Если клиент уже создан — ничего не делаем (защита от двойной инициализации)
    if _http is not None:
        return

    # -----------------------------------------------------------------
    # TIMEOUT'Ы (лимиты ожидания)
    # -----------------------------------------------------------------
    # connect — сколько ждём установления соединения (TCP/TLS handshake)
    # read    — сколько ждём, пока сервер пришлёт ответ
    # write   — сколько ждём, пока отправим запрос
    # pool    — сколько ждём свободное соединение из пула (если все заняты)
    #
    # Эти числа — пример "разумных дефолтов". Их можно адаптировать под проект.
    timeout = httpx.Timeout(connect=3.0, read=10.0, write=10.0, pool=3.0)

    # -----------------------------------------------------------------
    # LIMITS (ограничения пула соединений)
    # -----------------------------------------------------------------
    # max_connections — максимум одновременных соединений
    # max_keepalive_connections — сколько keep-alive соединений держать "тёплыми"
    #
    # Если ваш сервис делает много параллельных запросов — это важно.
    limits = httpx.Limits(max_connections=200, max_keepalive_connections=50)

    # -----------------------------------------------------------------
    # СОЗДАЁМ КЛИЕНТА
    # -----------------------------------------------------------------
    # AsyncClient внутри держит пул соединений и переиспользует их.
    # Это и есть главная причина, почему мы делаем его общим.
    _http = httpx.AsyncClient(timeout=timeout, limits=limits)


def get_http() -> httpx.AsyncClient:
    """
    Получить общий httpx.AsyncClient.

    Почему эта функция НЕ async?
    - Она ничего не ждёт и не делает I/O.
    - Она просто возвращает уже созданный объект.

    Что будет, если забыть вызвать init_clients()?
    - Мы выбросим RuntimeError, чтобы сразу обнаружить ошибку (fail-fast).
    """
    if _http is None:
        raise RuntimeError(
            "HTTP client is not initialized. "
            "Call init_clients() on startup (e.g. in main_v2.py)."
        )
    return _http


async def close_clients() -> None:
    """
    Закрываем HTTP-клиент.

    Зачем закрывать?
    - чтобы корректно закрыть сокеты/соединения
    - чтобы не было предупреждений и утечек ресурсов
    - чтобы shutdown был аккуратным

    Когда вызывать?
    - РОВНО 1 раз при остановке процесса (обычно в finally в main_v2.py)

    Поведение:
    - если клиента нет (None) — просто ничего не делаем
    """
    global _http

    # Если клиент был создан — закрываем.
    if _http is not None:
        await _http.aclose()  # корректно закрывает пул соединений
        _http = None          # обнуляем ссылку, чтобы случайно не использовать закрытый клиент
